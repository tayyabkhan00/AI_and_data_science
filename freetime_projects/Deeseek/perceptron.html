<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Network: How Weights and Biases Work</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            padding: 20px 0 30px;
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            color: #4cc9f0;
            text-shadow: 0 0 10px rgba(76, 201, 240, 0.5);
        }
        
        .subtitle {
            font-size: 1.2rem;
            color: #a9d6e5;
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.6;
        }
        
        .content {
            display: flex;
            flex-direction: column;
            gap: 30px;
        }
        
        .explanation {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(76, 201, 240, 0.1);
        }
        
        h2 {
            color: #72efdd;
            margin-bottom: 15px;
            font-size: 1.8rem;
        }
        
        p {
            line-height: 1.7;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }
        
        .analogy {
            background: rgba(114, 239, 221, 0.1);
            border-left: 4px solid #72efdd;
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }
        
        .analogy h3 {
            color: #72efdd;
            margin-bottom: 8px;
        }
        
        .visualization-area {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            justify-content: center;
        }
        
        .digit-input {
            flex: 1;
            min-width: 300px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(76, 201, 240, 0.1);
        }
        
        .neural-network {
            flex: 2;
            min-width: 500px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(76, 201, 240, 0.1);
        }
        
        .digit-canvas-container {
            background: #000;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            display: flex;
            justify-content: center;
        }
        
        #digitCanvas {
            background: #000;
            border: 1px solid #333;
            cursor: crosshair;
        }
        
        .canvas-controls {
            display: flex;
            gap: 15px;
            margin-top: 15px;
            justify-content: center;
        }
        
        button {
            background: linear-gradient(to right, #4361ee, #3a0ca3);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 50px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(67, 97, 238, 0.4);
        }
        
        .neural-network-container {
            position: relative;
            height: 400px;
            margin-top: 20px;
        }
        
        #networkCanvas {
            width: 100%;
            height: 100%;
            border-radius: 10px;
        }
        
        .weight-value, .bias-value {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.9rem;
            pointer-events: none;
            border: 1px solid #4cc9f0;
            color: #4cc9f0;
        }
        
        .neuron {
            position: absolute;
            border-radius: 50%;
            background: linear-gradient(145deg, #3a0ca3, #4361ee);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            box-shadow: 0 0 10px rgba(67, 97, 238, 0.5);
            z-index: 10;
        }
        
        .output-value {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 1rem;
            pointer-events: none;
            border: 1px solid #f72585;
            color: #f72585;
        }
        
        .output-label {
            position: absolute;
            color: #f72585;
            font-weight: bold;
            font-size: 1.2rem;
        }
        
        .step-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }
        
        .step-button {
            background: linear-gradient(to right, #f72585, #b5179e);
        }
        
        .instructions {
            margin-top: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            border: 1px solid rgba(76, 201, 240, 0.1);
        }
        
        .instructions h3 {
            color: #4cc9f0;
            margin-bottom: 10px;
        }
        
        .instructions ol {
            padding-left: 20px;
            line-height: 1.7;
        }
        
        .instructions li {
            margin-bottom: 10px;
        }
        
        .highlight {
            color: #72efdd;
            font-weight: bold;
        }
        
        @media (max-width: 900px) {
            .visualization-area {
                flex-direction: column;
            }
            
            .digit-input, .neural-network {
                min-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>How Weights and Biases Work in Neural Networks</h1>
            <p class="subtitle">Watch how a neural network uses weights and biases to recognize handwritten digits. Draw a "5" in the box below and see how the network processes it!</p>
        </header>
        
        <div class="content">
            <div class="explanation">
                <h2>What are Weights and Biases?</h2>
                <p>Imagine you're trying to recognize if an animal is a cat or a dog. You might look at features like ear shape, tail length, and size. Your brain gives more importance (weight) to some features than others when making a decision.</p>
                
                <div class="analogy">
                    <h3>Simple Analogy: Recognizing a Friend</h3>
                    <p>When you recognize a friend, your brain automatically:</p>
                    <ul>
                        <li><span class="highlight">Weights:</span> Gives more importance to their face than their shoes</li>
                        <li><span class="highlight">Biases:</span> Adjusts for different lighting conditions or hairstyles</li>
                    </ul>
                    <p>Similarly, a neural network uses weights and biases to recognize patterns in data!</p>
                </div>
                
                <p>In a neural network, <span class="highlight">weights</span> determine how important each input is, and <span class="highlight">biases</span> help adjust the output to make it more accurate. When you draw a digit, the network multiplies each pixel by a weight, adds a bias, and combines everything to make a prediction.</p>
            </div>
            
            <div class="visualization-area">
                <div class="digit-input">
                    <h2>Draw a Digit (Preferably "5")</h2>
                    <div class="digit-canvas-container">
                        <canvas id="digitCanvas" width="280" height="280"></canvas>
                    </div>
                    <div class="canvas-controls">
                        <button id="clearBtn">Clear Drawing</button>
                        <button id="sample5Btn">Load Sample "5"</button>
                        <button id="processBtn">Process Digit</button>
                    </div>
                    <p>Draw a digit in the box above, then click "Process Digit" to see how the neural network analyzes it using weights and biases!</p>
                </div>
                
                <div class="neural-network">
                    <h2>Neural Network Visualization</h2>
                    <p>Watch how the digit is processed through the network layers. The <span class="highlight" style="color: #4cc9f0;">blue lines</span> show weights (thicker = more important), and the <span class="highlight" style="color: #f72585;">red numbers</span> show biases.</p>
                    
                    <div class="neural-network-container">
                        <canvas id="networkCanvas" width="800" height="400"></canvas>
                        <!-- Weight and bias indicators will be dynamically added here -->
                    </div>
                    
                    <div class="step-controls">
                        <button id="step1Btn" class="step-button">Step 1: Show Input</button>
                        <button id="step2Btn" class="step-button">Step 2: Apply Weights</button>
                        <button id="step3Btn" class="step-button">Step 3: Add Biases</button>
                        <button id="step4Btn" class="step-button">Step 4: See Output</button>
                    </div>
                </div>
            </div>
            
            <div class="instructions">
                <h3>How to Use This Visualization</h3>
                <ol>
                    <li><span class="highlight">Draw a digit</span> (like "5") in the drawing area or click "Load Sample '5'"</li>
                    <li>Click <span class="highlight">"Process Digit"</span> to see how the neural network analyzes your drawing</li>
                    <li>Use the <span class="highlight">step buttons</span> to walk through each stage of the process:
                        <ul>
                            <li><strong>Step 1:</strong> Shows your drawing as input to the network</li>
                            <li><strong>Step 2:</strong> Shows how weights multiply each input (blue lines show importance)</li>
                            <li><strong>Step 3:</strong> Shows biases being added to adjust the calculation</li>
                            <li><strong>Step 4:</strong> Shows the final output - which digit the network thinks you drew</li>
                        </ul>
                    </li>
                    <li>Try drawing different digits to see how the weights and biases change the output!</li>
                </ol>
            </div>
        </div>
    </div>

    <script>
        // Get canvas elements
        const digitCanvas = document.getElementById('digitCanvas');
        const networkCanvas = document.getElementById('networkCanvas');
        const digitCtx = digitCanvas.getContext('2d');
        const networkCtx = networkCanvas.getContext('2d');
        
        // Canvas drawing variables
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        
        // Neural network simulation variables
        let currentStep = 0;
        let digitData = null;
        let weights = [];
        let biases = [];
        let neuronValues = [];
        let outputValues = Array(10).fill(0);
        
        // Initialize the digit canvas
        function initDigitCanvas() {
            digitCtx.fillStyle = 'black';
            digitCtx.fillRect(0, 0, digitCanvas.width, digitCanvas.height);
            digitCtx.strokeStyle = 'white';
            digitCtx.lineWidth = 15;
            digitCtx.lineCap = 'round';
            digitCtx.lineJoin = 'round';
        }
        
        // Initialize neural network with random weights and biases
        function initNeuralNetwork() {
            // Create random weights and biases for demonstration
            // Input layer: 28x28 pixels = 784 neurons
            // Hidden layer: 16 neurons
            // Output layer: 10 neurons (digits 0-9)
            
            weights = [];
            biases = [];
            
            // Initialize weights between input and hidden layer (784x16)
            for (let i = 0; i < 784; i++) {
                weights[i] = [];
                for (let j = 0; j < 16; j++) {
                    // Random weights between -0.5 and 0.5
                    weights[i][j] = (Math.random() - 0.5);
                }
            }
            
            // Initialize biases for hidden layer (16)
            for (let i = 0; i < 16; i++) {
                // Random biases between -0.5 and 0.5
                biases[i] = (Math.random() - 0.5) * 0.5;
            }
            
            // Initialize output weights and biases
            weights.output = [];
            biases.output = [];
            
            // Weights from hidden to output layer (16x10)
            for (let i = 0; i < 16; i++) {
                weights.output[i] = [];
                for (let j = 0; j < 10; j++) {
                    weights.output[i][j] = (Math.random() - 0.5);
                }
            }
            
            // Biases for output layer (10)
            for (let i = 0; i < 10; i++) {
                biases.output[i] = (Math.random() - 0.5) * 0.5;
            }
            
            // Initialize neuron values
            neuronValues = {
                input: Array(784).fill(0),
                hidden: Array(16).fill(0),
                output: Array(10).fill(0)
            };
        }
        
        // Process the drawn digit
        function processDigit() {
            // Get pixel data from canvas
            const imageData = digitCtx.getImageData(0, 0, digitCanvas.width, digitCanvas.height);
            const data = imageData.data;
            
            // Convert to grayscale and downsample to 28x28
            digitData = [];
            const blockSize = 10; // 280/28 = 10
            
            for (let y = 0; y < 28; y++) {
                for (let x = 0; x < 28; x++) {
                    let sum = 0;
                    
                    // Average the 10x10 block
                    for (let dy = 0; dy < blockSize; dy++) {
                        for (let dx = 0; dx < blockSize; dx++) {
                            const px = (y * blockSize + dy) * digitCanvas.width * 4 + (x * blockSize + dx) * 4;
                            // Use only the red channel (all channels are same for grayscale)
                            sum += data[px];
                        }
                    }
                    
                    // Normalize to 0-1 range (invert since black background)
                    const value = 1 - (sum / (blockSize * blockSize * 255));
                    digitData[y * 28 + x] = value;
                }
            }
            
            // Set input neuron values
            for (let i = 0; i < 784; i++) {
                neuronValues.input[i] = digitData[i];
            }
            
            // Simulate neural network processing
            simulateNeuralNetwork();
            
            // Start visualization
            currentStep = 1;
            drawNeuralNetwork();
        }
        
        // Simulate the neural network forward pass
        function simulateNeuralNetwork() {
            // Clear previous values
            neuronValues.hidden.fill(0);
            neuronValues.output.fill(0);
            outputValues.fill(0);
            
            // Calculate hidden layer values
            for (let i = 0; i < 16; i++) {
                let sum = 0;
                
                for (let j = 0; j < 784; j++) {
                    sum += neuronValues.input[j] * weights[j][i];
                }
                
                // Add bias and apply activation function (sigmoid)
                sum += biases[i];
                neuronValues.hidden[i] = 1 / (1 + Math.exp(-sum));
            }
            
            // Calculate output layer values
            for (let i = 0; i < 10; i++) {
                let sum = 0;
                
                for (let j = 0; j < 16; j++) {
                    sum += neuronValues.hidden[j] * weights.output[j][i];
                }
                
                // Add bias and apply activation function
                sum += biases.output[i];
                neuronValues.output[i] = 1 / (1 + Math.exp(-sum));
                outputValues[i] = neuronValues.output[i];
            }
        }
        
        // Draw the neural network visualization
        function drawNeuralNetwork() {
            // Clear canvas
            networkCtx.fillStyle = 'rgba(10, 15, 35, 0.9)';
            networkCtx.fillRect(0, 0, networkCanvas.width, networkCanvas.height);
            
            // Draw layers
            const layerSpacing = networkCanvas.width / 4;
            const neuronRadius = 15;
            
            // Draw connections based on current step
            if (currentStep >= 2) {
                // Draw weights between input and hidden layer
                for (let i = 0; i < Math.min(28, 784); i += 28) { // Sample input neurons
                    for (let j = 0; j < 16; j++) {
                        const x1 = layerSpacing;
                        const y1 = 50 + (i / 28) * (networkCanvas.height - 100) / 28;
                        const x2 = layerSpacing * 2;
                        const y2 = 50 + j * (networkCanvas.height - 100) / 16;
                        
                        // Weight value determines line width and color
                        const weight = weights[i][j];
                        const alpha = Math.abs(weight) * 2;
                        
                        networkCtx.beginPath();
                        networkCtx.moveTo(x1, y1);
                        networkCtx.lineTo(x2, y2);
                        networkCtx.lineWidth = Math.abs(weight) * 8;
                        networkCtx.strokeStyle = weight > 0 ? 
                            `rgba(76, 201, 240, ${alpha})` : 
                            `rgba(247, 37, 133, ${alpha})`;
                        networkCtx.stroke();
                    }
                }
                
                // Draw weights between hidden and output layer if step 3 or 4
                if (currentStep >= 3) {
                    for (let i = 0; i < 16; i++) {
                        for (let j = 0; j < 10; j++) {
                            const x1 = layerSpacing * 2;
                            const y1 = 50 + i * (networkCanvas.height - 100) / 16;
                            const x2 = layerSpacing * 3;
                            const y2 = 50 + j * (networkCanvas.height - 100) / 10;
                            
                            // Weight value determines line width and color
                            const weight = weights.output[i][j];
                            const alpha = Math.abs(weight) * 2;
                            
                            networkCtx.beginPath();
                            networkCtx.moveTo(x1, y1);
                            networkCtx.lineTo(x2, y2);
                            networkCtx.lineWidth = Math.abs(weight) * 8;
                            networkCtx.strokeStyle = weight > 0 ? 
                                `rgba(76, 201, 240, ${alpha})` : 
                                `rgba(247, 37, 133, ${alpha})`;
                            networkCtx.stroke();
                        }
                    }
                }
            }
            
            // Draw input layer neurons
            for (let i = 0; i < Math.min(28, 784); i += 28) { // Show only 28 neurons for clarity
                const x = layerSpacing;
                const y = 50 + (i / 28) * (networkCanvas.height - 100) / 28;
                
                // Draw neuron
                networkCtx.beginPath();
                networkCtx.arc(x, y, neuronRadius, 0, Math.PI * 2);
                
                // Color based on activation if step 1 or later
                if (currentStep >= 1 && digitData) {
                    const activation = digitData[i];
                    const intensity = Math.floor(activation * 255);
                    networkCtx.fillStyle = `rgb(${intensity}, ${intensity}, ${intensity})`;
                } else {
                    networkCtx.fillStyle = '#3a0ca3';
                }
                
                networkCtx.fill();
                networkCtx.strokeStyle = '#4361ee';
                networkCtx.lineWidth = 2;
                networkCtx.stroke();
                
                // Draw label for first neuron
                if (i === 0) {
                    networkCtx.fillStyle = 'white';
                    networkCtx.font = 'bold 16px Arial';
                    networkCtx.fillText('Input Layer', x - 40, 30);
                    networkCtx.font = '12px Arial';
                    networkCtx.fillText('(28x28 pixels)', x - 35, 45);
                }
            }
            
            // Draw hidden layer neurons
            for (let i = 0; i < 16; i++) {
                const x = layerSpacing * 2;
                const y = 50 + i * (networkCanvas.height - 100) / 16;
                
                // Draw neuron
                networkCtx.beginPath();
                networkCtx.arc(x, y, neuronRadius, 0, Math.PI * 2);
                
                // Color based on activation if step 2 or later
                if (currentStep >= 2) {
                    const activation = neuronValues.hidden[i];
                    const intensity = Math.floor(activation * 200);
                    networkCtx.fillStyle = `rgb(${intensity}, 100, 255)`;
                } else {
                    networkCtx.fillStyle = '#3a0ca3';
                }
                
                networkCtx.fill();
                networkCtx.strokeStyle = '#4361ee';
                networkCtx.lineWidth = 2;
                networkCtx.stroke();
                
                // Show bias if step 3 or later
                if (currentStep >= 3) {
                    const bias = biases[i];
                    networkCtx.fillStyle = bias > 0 ? '#4cc9f0' : '#f72585';
                    networkCtx.font = 'bold 12px Arial';
                    networkCtx.fillText(bias.toFixed(2), x + 25, y + 5);
                }
                
                // Draw label for first neuron
                if (i === 0) {
                    networkCtx.fillStyle = 'white';
                    networkCtx.font = 'bold 16px Arial';
                    networkCtx.fillText('Hidden Layer', x - 40, 30);
                    networkCtx.font = '12px Arial';
                    networkCtx.fillText('(16 neurons)', x - 30, 45);
                }
            }
            
            // Draw output layer neurons
            for (let i = 0; i < 10; i++) {
                const x = layerSpacing * 3;
                const y = 50 + i * (networkCanvas.height - 100) / 10;
                
                // Draw neuron
                networkCtx.beginPath();
                networkCtx.arc(x, y, neuronRadius, 0, Math.PI * 2);
                
                // Color based on activation if step 4
                if (currentStep >= 4) {
                    const activation = neuronValues.output[i];
                    const intensity = Math.floor(activation * 200);
                    
                    // Highlight the digit with highest activation
                    const maxActivation = Math.max(...neuronValues.output);
                    const isPredicted = Math.abs(activation - maxActivation) < 0.001;
                    
                    if (isPredicted) {
                        networkCtx.fillStyle = `rgb(255, ${intensity}, 100)`;
                        networkCtx.shadowColor = '#ffbe0b';
                        networkCtx.shadowBlur = 15;
                    } else {
                        networkCtx.fillStyle = `rgb(${intensity}, 100, 255)`;
                    }
                } else {
                    networkCtx.fillStyle = '#3a0ca3';
                }
                
                networkCtx.fill();
                networkCtx.strokeStyle = '#4361ee';
                networkCtx.lineWidth = 2;
                networkCtx.stroke();
                networkCtx.shadowBlur = 0;
                
                // Show digit label
                networkCtx.fillStyle = 'white';
                networkCtx.font = 'bold 14px Arial';
                networkCtx.fillText(i, x, y + 5);
                
                // Show output value if step 4
                if (currentStep >= 4) {
                    const output = neuronValues.output[i];
                    networkCtx.fillStyle = output > 0.5 ? '#4cc9f0' : '#f72585';
                    networkCtx.font = 'bold 12px Arial';
                    networkCtx.fillText(output.toFixed(2), x + 25, y + 5);
                }
                
                // Show bias if step 3 or later (but not 4 to avoid clutter)
                if (currentStep === 3) {
                    const bias = biases.output[i];
                    networkCtx.fillStyle = bias > 0 ? '#4cc9f0' : '#f72585';
                    networkCtx.font = 'bold 12px Arial';
                    networkCtx.fillText(bias.toFixed(2), x + 25, y + 5);
                }
                
                // Draw label for first neuron
                if (i === 0) {
                    networkCtx.fillStyle = 'white';
                    networkCtx.font = 'bold 16px Arial';
                    networkCtx.fillText('Output Layer', x - 40, 30);
                    networkCtx.font = '12px Arial';
                    networkCtx.fillText('(Digits 0-9)', x - 30, 45);
                }
            }
            
            // Draw explanation based on current step
            networkCtx.fillStyle = 'white';
            networkCtx.font = 'bold 18px Arial';
            networkCtx.textAlign = 'center';
            
            let explanation = '';
            if (currentStep === 0) {
                explanation = 'Click "Process Digit" to start!';
            } else if (currentStep === 1) {
                explanation = 'Step 1: Your drawing is fed into the input layer (28x28 pixels = 784 neurons)';
            } else if (currentStep === 2) {
                explanation = 'Step 2: Weights multiply each input (blue/pink lines show importance)';
            } else if (currentStep === 3) {
                explanation = 'Step 3: Biases are added to adjust the calculation (colored numbers)';
            } else if (currentStep === 4) {
                // Find predicted digit
                const maxActivation = Math.max(...neuronValues.output);
                const predictedDigit = neuronValues.output.indexOf(maxActivation);
                
                explanation = `Step 4: The network thinks you drew a ${predictedDigit}! (Confidence: ${(maxActivation * 100).toFixed(1)}%)`;
                
                // Highlight the predicted digit
                networkCtx.fillStyle = '#ffbe0b';
                networkCtx.font = 'bold 24px Arial';
                networkCtx.fillText(`Predicted: ${predictedDigit}`, networkCanvas.width / 2, networkCanvas.height - 10);
            }
            
            networkCtx.fillStyle = '#72efdd';
            networkCtx.fillText(explanation, networkCanvas.width / 2, networkCanvas.height - 40);
            networkCtx.textAlign = 'left';
        }
        
        // Event listeners for drawing
        digitCanvas.addEventListener('mousedown', startDrawing);
        digitCanvas.addEventListener('mousemove', draw);
        digitCanvas.addEventListener('mouseup', stopDrawing);
        digitCanvas.addEventListener('mouseout', stopDrawing);
        
        function startDrawing(e) {
            isDrawing = true;
            [lastX, lastY] = getMousePos(e);
        }
        
        function draw(e) {
            if (!isDrawing) return;
            
            const [x, y] = getMousePos(e);
            
            digitCtx.beginPath();
            digitCtx.moveTo(lastX, lastY);
            digitCtx.lineTo(x, y);
            digitCtx.stroke();
            
            [lastX, lastY] = [x, y];
        }
        
        function stopDrawing() {
            isDrawing = false;
        }
        
        function getMousePos(e) {
            const rect = digitCanvas.getBoundingClientRect();
            return [
                e.clientX - rect.left,
                e.clientY - rect.top
            ];
        }
        
        // Event listeners for buttons
        document.getElementById('clearBtn').addEventListener('click', () => {
            initDigitCanvas();
            currentStep = 0;
            drawNeuralNetwork();
        });
        
        document.getElementById('sample5Btn').addEventListener('click', () => {
            initDigitCanvas();
            
            // Draw a sample "5"
            digitCtx.beginPath();
            digitCtx.moveTo(70, 50);
            digitCtx.lineTo(200, 50);
            digitCtx.lineTo(200, 120);
            digitCtx.lineTo(100, 120);
            digitCtx.lineTo(100, 150);
            digitCtx.lineTo(200, 150);
            digitCtx.lineTo(200, 230);
            digitCtx.lineTo(70, 230);
            digitCtx.lineTo(70, 170);
            digitCtx.lineTo(170, 170);
            digitCtx.lineTo(170, 200);
            digitCtx.lineTo(100, 200);
            digitCtx.lineTo(100, 80);
            digitCtx.lineTo(200, 80);
            digitCtx.lineTo(200, 50);
            digitCtx.closePath();
            digitCtx.fillStyle = 'white';
            digitCtx.fill();
            
            // Process it automatically
            setTimeout(processDigit, 500);
        });
        
        document.getElementById('processBtn').addEventListener('click', processDigit);
        
        document.getElementById('step1Btn').addEventListener('click', () => {
            if (digitData) {
                currentStep = 1;
                drawNeuralNetwork();
            }
        });
        
        document.getElementById('step2Btn').addEventListener('click', () => {
            if (digitData) {
                currentStep = 2;
                drawNeuralNetwork();
            }
        });
        
        document.getElementById('step3Btn').addEventListener('click', () => {
            if (digitData) {
                currentStep = 3;
                drawNeuralNetwork();
            }
        });
        
        document.getElementById('step4Btn').addEventListener('click', () => {
            if (digitData) {
                currentStep = 4;
                drawNeuralNetwork();
            }
        });
        
        // Initialize everything
        initDigitCanvas();
        initNeuralNetwork();
        drawNeuralNetwork();
        
        // Add touch support for mobile devices
        digitCanvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            digitCanvas.dispatchEvent(mouseEvent);
        });
        
        digitCanvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            digitCanvas.dispatchEvent(mouseEvent);
        });
        
        digitCanvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            const mouseEvent = new MouseEvent('mouseup', {});
            digitCanvas.dispatchEvent(mouseEvent);
        });
    </script>
</body>
</html>