<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Particle Attractor Playground</title>
<style>
  :root{
    --bg:#0b1020;
    --panel:#0f1724cc;
    --accent:#6ee7b7;
    --muted:#9aa8bf;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;}
  body{background:linear-gradient(180deg,#07101b 0%, #071425 100%);display:flex;align-items:stretch}
  #app{flex:1;display:flex;gap:12px;padding:12px;box-sizing:border-box}
  #canvas-wrap{flex:1;border-radius:12px;overflow:hidden;box-shadow:0 10px 30px rgba(2,6,23,.6)}
  canvas{display:block;width:100%;height:100%;background:transparent}
  #panel{width:320px;min-width:220px;background:var(--panel);color:#e6eef8;padding:14px;border-radius:12px}
  h1{font-size:18px;margin:0 0 8px}
  label{display:block;font-size:13px;color:var(--muted);margin-top:10px}
  .row{display:flex;gap:8px;align-items:center;margin-top:8px}
  input[type=range]{width:100%}
  .btn{appearance:none;border:0;padding:8px 10px;border-radius:8px;background:#0b1220;color:var(--accent);cursor:pointer}
  .small{font-size:12px;color:var(--muted)}
  footer{font-size:12px;color:var(--muted);margin-top:12px}
  .mode-btn{padding:8px;border-radius:8px;border:1px solid transparent;background:transparent;color:var(--muted);cursor:pointer}
  .mode-btn.active{border-color:rgba(110,231,183,.18);color:var(--accent)}
</style>
</head>
<body>
<div id="app">
  <div id="canvas-wrap">
    <canvas id="c"></canvas>
  </div>
  <div id="panel">
    <h1>Particle Attractor Playground</h1>
    <div class="small">Interactive particle system — try moving the mouse, change modes and sliders.</div>

    <label>Mode</label>
    <div class="row" id="modes">
      <button class="mode-btn active" data-mode="mouse">Mouse Attractor</button>
      <button class="mode-btn" data-mode="orbit">Moving Attractors</button>
    </div>

    <label>Particles: <span id="pcountLabel">1200</span></label>
    <input id="particleCount" type="range" min="100" max="5000" value="1200" step="50">

    <label>Attraction Strength: <span id="strengthLabel">120</span></label>
    <input id="strength" type="range" min="-500" max="500" value="120">

    <label>Friction (0 = no dissipation): <span id="fricLabel">0.02</span></label>
    <input id="friction" type="range" min="0" max="0.1" step="0.001" value="0.02">

    <label>Trail Fade (0 = solid trails, 1 = no trails): <span id="trailLabel">0.12</span></label>
    <input id="trail" type="range" min="0" max="1" step="0.01" value="0.12">

    <label>Attractors: <span id="atrCountLabel">3</span></label>
    <input id="attractorCount" type="range" min="1" max="8" value="3">

    <label>Attractor Speed: <span id="atrSpeedLabel">0.6</span></label>
    <input id="attractorSpeed" type="range" min="0" max="3" step="0.1" value="0.6">

    <div class="row" style="margin-top:12px">
      <button id="resetBtn" class="btn">Reset Particles</button>
      <button id="randomize" class="btn" style="margin-left:8px">Randomize Attractors</button>
    </div>

    <footer>Tip: negative Strength → repulsion. Increase Trail Fade to see crisp particle motion.</footer>
  </div>
</div>

<script>
/*
  Particle Attractors Playground
  - Save as particle-attractors.html and open in a modern browser.
  - No external libraries.
*/

// Utilities
const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
const rand = (a=0,b=1)=> a + Math.random()*(b-a);

// Canvas setup
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha: true });

// UI elements
const ui = {
  particleCount: document.getElementById('particleCount'),
  pcountLabel: document.getElementById('pcountLabel'),
  strength: document.getElementById('strength'),
  strengthLabel: document.getElementById('strengthLabel'),
  friction: document.getElementById('friction'),
  fricLabel: document.getElementById('fricLabel'),
  trail: document.getElementById('trail'),
  trailLabel: document.getElementById('trailLabel'),
  attractorCount: document.getElementById('attractorCount'),
  atrCountLabel: document.getElementById('atrCountLabel'),
  attractorSpeed: document.getElementById('attractorSpeed'),
  atrSpeedLabel: document.getElementById('atrSpeedLabel'),
  resetBtn: document.getElementById('resetBtn'),
  randomize: document.getElementById('randomize'),
  modes: document.getElementById('modes')
};

// State and resize
let W = 800, H = 600;
function resize(){
  const dpr = window.devicePixelRatio || 1;
  W = canvas.clientWidth = canvas.parentElement.clientWidth;
  H = canvas.clientHeight = canvas.parentElement.clientHeight;
  canvas.width = Math.max(1, Math.floor(W * dpr));
  canvas.height = Math.max(1, Math.floor(H * dpr));
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', resize);
resize();

// Physics config (will read from UI)
let cfg = {
  particleCount: +ui.particleCount.value,
  strength: +ui.strength.value,
  friction: +ui.friction.value,
  trailFade: +ui.trail.value,
  attractorCount: +ui.attractorCount.value,
  attractorSpeed: +ui.attractorSpeed.value,
  mode: 'mouse'
};

// Particles (pool)
class Particle {
  constructor(){
    this.reset(true);
  }
  reset(randomizePosition=false){
    if(randomizePosition){
      this.x = rand(0, W);
      this.y = rand(0, H);
    } else {
      this.x = W/2; this.y = H/2;
    }
    this.vx = rand(-0.2,0.2);
    this.vy = rand(-0.2,0.2);
    this.life = 0;
    this.size = rand(0.6,1.6);
    this.hue = rand(160,210); // teal-blueish
  }
  applyForce(fx,fy){
    this.vx += fx;
    this.vy += fy;
  }
  integrate(dt){
    this.vx *= (1 - cfg.friction);
    this.vy *= (1 - cfg.friction);
    this.x += this.vx * dt;
    this.y += this.vy * dt;
    this.life += dt;
    // wrap-around to keep particles alive and on canvas
    if(this.x < -10) this.x = W+10;
    if(this.x > W+10) this.x = -10;
    if(this.y < -10) this.y = H+10;
    if(this.y > H+10) this.y = -10;
  }
  draw(ctx){
    ctx.beginPath();
    ctx.fillStyle = `hsla(${this.hue},80%,60%,0.9)`;
    ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
    ctx.fill();
  }
}

// Attractors
class Attractor {
  constructor(x,y,m=1){
    this.x = x; this.y = y; this.m = m;
    // orbital params for "moving attractors" mode
    this.orbitCenterX = x;
    this.orbitCenterY = y;
    this.angle = rand(0, Math.PI*2);
    this.radius = rand(40, Math.min(W,H)/4);
    this.speed = rand(0.2, 1);
  }
  step(t){
    // circular orbit around center
    this.angle += this.speed * cfg.attractorSpeed * 0.01;
    this.x = this.orbitCenterX + Math.cos(this.angle) * this.radius;
    this.y = this.orbitCenterY + Math.sin(this.angle) * this.radius;
  }
  draw(ctx){
    ctx.beginPath();
    ctx.fillStyle = `rgba(255,255,255,0.6)`;
    ctx.arc(this.x, this.y, Math.max(2, Math.log(Math.abs(this.m)+1)*2), 0, Math.PI*2);
    ctx.fill();
  }
}

// Create particle pool and attractors
let particles = [];
let attractors = [];
function initParticles(count){
  particles.length = 0;
  for(let i=0;i<count;i++){
    particles.push(new Particle());
  }
}
function initAttractors(n){
  attractors.length = 0;
  for(let i=0;i<n;i++){
    const cx = W/2 + Math.cos(i/n*Math.PI*2) * Math.min(W,H)*0.15;
    const cy = H/2 + Math.sin(i/n*Math.PI*2) * Math.min(W,H)*0.12;
    const m = rand(50, 220);
    const a = new Attractor(cx,cy,m);
    a.speed = rand(0.1, 1) * (i%2?1:-1);
    attractors.push(a);
  }
}

// Initial setup
initParticles(cfg.particleCount);
initAttractors(cfg.attractorCount);

// Mouse as single attractor
const mouse = {x: W/2, y: H/2, down:false};

// Input events
canvas.addEventListener('mousemove', e => {
  const rect = canvas.getBoundingClientRect();
  mouse.x = (e.clientX - rect.left);
  mouse.y = (e.clientY - rect.top);
});
canvas.addEventListener('mousedown', ()=> mouse.down=true);
canvas.addEventListener('mouseup', ()=> mouse.down=false);
canvas.addEventListener('mouseleave', ()=> mouse.down=false);

// UI bindings
function updateUIValues(){
  ui.pcountLabel.textContent = cfg.particleCount;
  ui.strengthLabel.textContent = cfg.strength;
  ui.fricLabel.textContent = Number(cfg.friction).toFixed(3);
  ui.trailLabel.textContent = Number(cfg.trailFade).toFixed(2);
  ui.atrCountLabel.textContent = cfg.attractorCount;
  ui.atrSpeedLabel.textContent = Number(cfg.attractorSpeed).toFixed(2);
}
ui.particleCount.addEventListener('input', e=>{
  cfg.particleCount = +e.target.value;
  ui.pcountLabel.textContent = cfg.particleCount;
});
ui.strength.addEventListener('input', e=>{
  cfg.strength = +e.target.value;
  ui.strengthLabel.textContent = cfg.strength;
});
ui.friction.addEventListener('input', e=>{
  cfg.friction = +e.target.value;
  ui.fricLabel.textContent = Number(cfg.friction).toFixed(3);
});
ui.trail.addEventListener('input', e=>{
  cfg.trailFade = +e.target.value;
  ui.trailLabel.textContent = Number(cfg.trailFade).toFixed(2);
});
ui.attractorCount.addEventListener('input', e=>{
  cfg.attractorCount = +e.target.value;
  ui.atrCountLabel.textContent = cfg.attractorCount;
});
ui.attractorSpeed.addEventListener('input', e=>{
  cfg.attractorSpeed = +e.target.value;
  ui.atrSpeedLabel.textContent = Number(cfg.attractorSpeed).toFixed(2);
});
ui.resetBtn.addEventListener('click', ()=>{
  initParticles(cfg.particleCount);
});
ui.randomize.addEventListener('click', ()=>{
  initAttractors(cfg.attractorCount);
});

// mode buttons
ui.modes.addEventListener('click', e=>{
  if(e.target.dataset && e.target.dataset.mode){
    cfg.mode = e.target.dataset.mode;
    [...ui.modes.children].forEach(b=>b.classList.remove('active'));
    e.target.classList.add('active');
  }
});

// Frame loop
let last = performance.now();
function step(now){
  const dt = Math.min(32, now - last) * 0.06; // scale to make movement reasonable
  last = now;
  // handle canvas size changes
  resize();

  // adapt particle count (grow/shrink)
  if(particles.length < cfg.particleCount){
    const toAdd = cfg.particleCount - particles.length;
    for(let i=0;i<toAdd;i++) particles.push(new Particle());
  } else if(particles.length > cfg.particleCount){
    particles.length = cfg.particleCount;
  }

  // update attractors if mode is orbit
  if(cfg.mode === 'orbit'){
    for(let a of attractors) a.step(now);
  }

  // draw fade (trail)
  ctx.fillStyle = `rgba(7,10,20,${cfg.trailFade})`;
  ctx.fillRect(0,0,W,H);

  // physics: for each particle sum forces from attractors (or mouse)
  const G = cfg.strength * 0.0008; // global scaling factor
  if(cfg.mode === 'mouse'){
    // single attractor = mouse
    const ax = mouse.x, ay = mouse.y;
    for(let p of particles){
      const dx = ax - p.x;
      const dy = ay - p.y;
      let r2 = dx*dx + dy*dy + 20; // softening
      // inverse square with clamp
      const invr = 1 / Math.sqrt(r2);
      const force = G / r2; // magnitude (sign included in G)
      // acceleration ~ force (particle mass = 1)
      p.applyForce(dx * invr * force * dt, dy * invr * force * dt);
      p.integrate(dt);
      p.draw(ctx);
    }
  } else {
    // multiple attractors
    // ensure attractor count matches UI
    if(attractors.length !== cfg.attractorCount) initAttractors(cfg.attractorCount);
    for(let p of particles){
      let fx = 0, fy = 0;
      for(let a of attractors){
        const dx = a.x - p.x;
        const dy = a.y - p.y;
        let r2 = dx*dx + dy*dy + 30; // avoid singularity
        const invr = 1 / Math.sqrt(r2);
        const f = (G * a.m) / r2;
        fx += dx * invr * f;
        fy += dy * invr * f;
      }
      p.applyForce(fx * dt, fy * dt);
      p.integrate(dt);
      p.draw(ctx);
    }
    // optionally draw attractors (glow)
    for(let a of attractors) {
      // soft glow
      const g = ctx.createRadialGradient(a.x,a.y,0,a.x,a.y,60);
      g.addColorStop(0, 'rgba(255,255,255,0.08)');
      g.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(a.x,a.y,60,0,Math.PI*2);
      ctx.fill();
      a.draw(ctx);
    }
  }

  requestAnimationFrame(step);
}
updateUIValues();
requestAnimationFrame(step);

// small animation: pulsate attractor centers slowly
setInterval(()=>{ // ensure attractor centers stay near canvas center
  for(let i=0;i<attractors.length;i++){
    attractors[i].orbitCenterX = W/2 + Math.cos(i)*W*0.02;
    attractors[i].orbitCenterY = H/2 + Math.sin(i)*H*0.02;
  }
}, 1000);

</script>
</body>
</html>
